# [Back to Index](../Index.md)

# Principal Software Engineer Duties

## Team Mentorship
Promote a culture of continuous learning and collaboration.
Pair junior engineers with experienced mentors for code reviews and knowledge sharing.
Conduct weekly knowledge-sharing sessions on tools, frameworks, or practices used in our stack.
Encourage participation in external conferences, courses, and certifications.

## Git (Gitflow)
Follow the Gitflow workflow:
- Main Branch: Stable and production-ready code.
- Develop Branch: Integration branch for development.
- Feature Branches for individual stories/tasks: Merge back into develop upon completion.
- Release Branches: For release preparation.
- Hotfix Branches: For quick fixes on main.
Use meaningful commit messages with clear descriptions (e.g., feat: add user authentication module).
Use Pull Requests (PRs) with mandatory code reviews before merging.

## Security
Use environment variables to store sensitive information (e.g., API keys, database credentials).
Regularly update dependencies and libraries to avoid vulnerabilities.
Use scanning software to find vulnerabilities in internal and external code.

## GitHub Copilot
Use GitHub Copilot to automate repetitive tasks, such as generating boilerplate code.
Always review the code generated by Copilot for security and quality concerns.
Share tips and tricks for using Copilot during team meetings or workshops.

## AI Tools
Evaluate and responsibly integrate AI tools into the development process (e.g., for testing, documentation, or debugging assistance).
Ensure ethical use of AI tools and avoid introducing proprietary or sensitive data into them.
Periodically review the efficiency and relevance of the AI tools in use.

## Company (Business)
Understand and align with the business objectives and mission of the company.
Involve cross-functional teams (product, design, QA) early in the development process.
Write clean, scalable, and maintainable code to support the company's long-term growth.

## .Net
Follow architectural standards established in conjunction with the architecture team.
Write modular and reusable code.
Use dependency injection for better testability and flexibility.
Use LINQ for efficient data queries and manipulation.

## Entity Framework and Database
Database Design: Use best design practices to model the database, ensuring normalization, performance, and scalability.
Migrations: Use Entity Framework migrations to version database schema changes and maintain control over alterations.
Efficient Queries: Prefer asynchronous queries to improve performance and avoid I/O operation blocks. Use methods like AsNoTracking() to enhance performance in scenarios where entity tracking is not needed.
Data Manipulation: Use TransactionScope to ensure integrity in operations involving multiple data changes.
Validation: Add validations to models and code to ensure data consistency and integrity.
Monitoring and Logs: Implement detailed logs to monitor query performance and identify potential bottlenecks.
Security: Use stored procedures or parameters when constructing SQL queries to prevent SQL injection attacks. Do not expose the database directly to the client.
Indexing Strategies: Configure appropriate indexes for columns frequently used in searches or filter conditions to improve performance.
Backup and Recovery: Plan a robust database backup and recovery strategy to ensure data safety in case of failures.

## Testing (.Net & xUnit)
Write unit tests for each critical function or feature using xUnit.
Aim for high test coverage, but prioritize meaningful tests over numbers.
Use mocking frameworks (e.g., Moq) to test dependencies.
Automate tests as part of the CI/CD pipeline.

## React
Follow a component-based architecture for better maintainability.
Use TypeScript for type safety and better tooling support.
Prefer functional components and React Hooks.
Manage application state efficiently with Context API or state management libraries like Redux.

## Testing (React & Jest)
Write unit and snapshot tests for React components using Jest.
Ensure coverage of edge cases and user interactions with tools like React Testing Library.
Automate tests using CI/CD pipelines.
Keep tests organized and ensure they are part of the acceptance criteria for all stories.
